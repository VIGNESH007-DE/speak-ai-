<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Socratic - Voice Assistant</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Roboto Mono', monospace;
            background: #0a0a0a;
            color: #e0e0e0;
        }
        #background-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
        }
        #socratic-bot {
            width: 200px;
            height: 200px;
            position: relative;
            transition: transform 0.5s ease-in-out;
        }
        .bot-core {
            width: 100px;
            height: 100px;
            background: radial-gradient(circle, #4f46e5 0%, #1e1b4b 100%);
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 30px #4f46e5, inset 0 0 20px rgba(255,255,255,0.3);
            animation: pulse 4s ease-in-out infinite;
        }
        .bot-ring {
            position: absolute;
            top: 50%;
            left: 50%;
            border: 3px solid;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            opacity: 0.5;
        }
        .ring1 { width: 150px; height: 150px; border-color: #a78bfa; animation: rotate 20s linear infinite; }
        .ring2 { width: 180px; height: 180px; border-color: #7c3aed; animation: rotate-reverse 25s linear infinite; }
        .ring3 { width: 210px; height: 210px; border-color: #6d28d9; animation: rotate 30s linear infinite; }
        
        @keyframes pulse {
            50% { box-shadow: 0 0 45px #6366f1, inset 0 0 25px rgba(255,255,255,0.4); }
        }
        @keyframes rotate {
            from { transform: translate(-50%, -50%) rotate(0deg); }
            to { transform: translate(-50%, -50%) rotate(360deg); }
        }
        @keyframes rotate-reverse {
            from { transform: translate(-50%, -50%) rotate(360deg); }
            to { transform: translate(-50%, -50%) rotate(0deg); }
        }

        #activate-btn.listening {
            animation: mic-pulse 1.5s infinite;
        }
        @keyframes mic-pulse {
            0%, 100% { box-shadow: 0 0 20px #22c55e; }
            50% { box-shadow: 0 0 40px #86efac; }
        }
    </style>
</head>
<body class="flex flex-col items-center justify-center h-screen p-4">

    <canvas id="background-canvas"></canvas>

    <div id="socratic-bot-container" class="mb-8">
        <div id="socratic-bot">
            <div class="bot-core"></div>
            <div class="bot-ring ring1"></div>
            <div class="bot-ring ring2"></div>
            <div class="bot-ring ring3"></div>
        </div>
    </div>

    <div id="status-display" class="text-center h-24">
        <p id="user-query" class="text-xl text-gray-400 h-1/2"></p>
        <p id="bot-answer" class="text-2xl font-bold text-white h-1/2"></p>
    </div>

    <button id="activate-btn" class="mt-8 bg-green-600 text-white rounded-full p-6 transition-all duration-300 hover:bg-green-500 focus:outline-none shadow-lg">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-10 w-10" viewBox="0 0 20 20" fill="currentColor">
            <path fill-rule="evenodd" d="M7 4a3 3 0 016 0v4a3 3 0 11-6 0V4zm5 8a1 1 0 100-2H8a1 1 0 100 2h4zM3 8a1 1 0 011-1h1v2H4a1 1 0 01-1-1zm13 0a1 1 0 00-1-1h-1v2h1a1 1 0 001-1z" clip-rule="evenodd" />
            <path d="M10 18a5 5 0 005-5h-2a3 3 0 01-6 0H5a5 5 0 005 5z" />
        </svg>
    </button>

    <script>
        // --- DOM Elements ---
        const backgroundCanvas = document.getElementById('background-canvas');
        const socraticBot = document.getElementById('socratic-bot');
        const activateBtn = document.getElementById('activate-btn');
        const userQueryDisplay = document.getElementById('user-query');
        const botAnswerDisplay = document.getElementById('bot-answer');

        // --- Background Animation ---
        const ctx = backgroundCanvas.getContext('2d');
        backgroundCanvas.width = window.innerWidth;
        backgroundCanvas.height = window.innerHeight;
        let particles = [];
        const mouse = { x: null, y: null, radius: 100 };

        window.addEventListener('mousemove', (event) => {
            mouse.x = event.x;
            mouse.y = event.y;
        });
        window.addEventListener('mouseout', () => {
            mouse.x = null;
            mouse.y = null;
        });

        class Particle {
            constructor(x, y, directionX, directionY, size, color) {
                this.x = x; this.y = y;
                this.directionX = directionX; this.directionY = directionY;
                this.size = size; this.color = color;
            }
            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2, false);
                ctx.fillStyle = this.color;
                ctx.fill();
            }
            update() {
                if (this.x > backgroundCanvas.width || this.x < 0) this.directionX = -this.directionX;
                if (this.y > backgroundCanvas.height || this.y < 0) this.directionY = -this.directionY;
                this.x += this.directionX;
                this.y += this.directionY;
                this.draw();
            }
        }

        function initParticles() {
            particles = [];
            let numberOfParticles = (backgroundCanvas.height * backgroundCanvas.width) / 9000;
            for (let i = 0; i < numberOfParticles; i++) {
                let size = (Math.random() * 2) + 1;
                let x = (Math.random() * ((innerWidth - size * 2) - (size * 2)) + size * 2);
                let y = (Math.random() * ((innerHeight - size * 2) - (size * 2)) + size * 2);
                let directionX = (Math.random() * .4) - .2;
                let directionY = (Math.random() * .4) - .2;
                let color = `rgba(79, 70, 229, ${Math.random()})`;
                particles.push(new Particle(x, y, directionX, directionY, size, color));
            }
        }

        function connectParticles() {
            for (let a = 0; a < particles.length; a++) {
                for (let b = a; b < particles.length; b++) {
                    let distance = Math.hypot(particles[a].x - particles[b].x, particles[a].y - particles[b].y);
                    if (distance < (backgroundCanvas.width/7) * (backgroundCanvas.height/7) / 100) {
                        ctx.strokeStyle=`rgba(129, 140, 248, ${1 - distance/200})`;
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(particles[a].x, particles[a].y);
                        ctx.lineTo(particles[b].x, particles[b].y);
                        ctx.stroke();
                    }
                }
            }
        }

        function animateBackground() {
            requestAnimationFrame(animateBackground);
            ctx.clearRect(0,0,innerWidth, innerHeight);
            particles.forEach(p => p.update());
            connectParticles();
        }
        
        initParticles();
        animateBackground();
        window.addEventListener('resize', () => {
            backgroundCanvas.width = window.innerWidth;
            backgroundCanvas.height = window.innerHeight;
            initParticles();
        });

        // --- Voice Recognition & Synthesis ---
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        const recognition = new SpeechRecognition();
        recognition.continuous = false;
        recognition.lang = 'en-US';
        recognition.interimResults = false;
        
        let isListening = false;
        
        recognition.onstart = () => {
            isListening = true;
            activateBtn.classList.add('listening');
            userQueryDisplay.textContent = "Listening...";
            botAnswerDisplay.textContent = "";
        };

        recognition.onend = () => {
            isListening = false;
            activateBtn.classList.remove('listening');
            userQueryDisplay.textContent = "Click the mic to ask a question";
        };
        
        recognition.onerror = (event) => {
            console.error("Speech recognition error:", event.error);
            userQueryDisplay.textContent = "Sorry, I didn't catch that.";
        };

        recognition.onresult = async (event) => {
            const transcript = event.results[0][0].transcript;
            userQueryDisplay.textContent = `You said: "${transcript}"`;
            await processQuery(transcript);
        };

        function speak(text, callback) {
            const utterance = new SpeechSynthesisUtterance(text);
            utterance.onstart = () => {
                gsap.to(socraticBot, { scale: 1.1, duration: 0.3, ease: 'power2.out' });
            };
            utterance.onend = () => {
                gsap.to(socraticBot, { scale: 1, duration: 0.5, ease: 'elastic.out(1, 0.3)' });
                if (callback) callback();
            };
            speechSynthesis.speak(utterance);
            botAnswerDisplay.textContent = text;
        }

        // --- Core Logic ---
        const youtubePlaylist = [
            "https://www.youtube.com/shorts/hJ91_sn3-e4", // Fast Multiplication
            "https://www.youtube.com/shorts/2iNag44_9gY", // Percentage Trick
            "https://www.youtube.com/shorts/EIe-Z22_3XU"  // Squaring numbers ending in 5
        ];
        let videoIndex = 0;

        async function processQuery(query) {
            const lowerQuery = query.toLowerCase();

            if (lowerQuery.includes("bored")) {
                recommendVideo();
                return;
            }
            
            const mathKeywords = ['what is', 'calculate', 'solve', 'plus', 'minus', 'times', 'divided by', 'power', '+', '-', '*', '/'];
            const isMathQuery = mathKeywords.some(kw => lowerQuery.includes(kw)) || /\d/.test(lowerQuery);

            if (isMathQuery) {
                // MODIFICATION: Call Gemini API instead of local solver
                await callGeminiApi(lowerQuery);
            } else {
                speak("I can only answer math-related questions. Please ask me something like 'what is 5 times 12'.");
            }
        }

        // MODIFICATION: New function to call Gemini API
        async function callGeminiApi(query) {
            const apiKey = "AIzaSyBoXwQ4i91HBFukPknxb6WM-13pJJ0s98U"; // This will be handled by the environment
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;
            
            const systemPrompt = `You are Socratic, a helpful math assistant. Your only task is to solve the mathematical expression or question provided by the user. 
            1. First, state the answer clearly.
            2. Then, provide a very brief, one-sentence explanation of the method if the question is complex (like algebra or calculus). For simple arithmetic, just give the answer.
            3. Your entire response must be spoken as a single, natural sentence.
            Example 1 (Simple): User says "what is 5 times 5". You respond "The answer is 25."
            Example 2 (Complex): User says "what is the integral of 2x". You respond "The integral of 2x is x squared plus a constant, which is found by applying the power rule."
            Do not say "Sure!" or any other conversational fillers.`;

            const payload = {
                contents: [{ parts: [{ text: query }] }],
                systemInstruction: { parts: [{ text: systemPrompt }] },
            };

            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                if (!response.ok) throw new Error(`API Error: ${response.status}`);
                const result = await response.json();
                if (result.candidates && result.candidates.length > 0 && result.candidates[0].content.parts) {
                    const botResponse = result.candidates[0].content.parts[0].text;
                    speak(botResponse);
                } else {
                    speak("I'm sorry, I couldn't process that request.");
                }
            } catch (error) {
                console.error("Gemini API Error:", error);
                speak("I'm having a little trouble connecting to my brain right now. Please try again in a moment.");
            }
        }
        
        function recommendVideo() {
            const videoUrl = youtubePlaylist[videoIndex];
            speak("Feeling bored? Here is a link to a short video with a cool math trick.");
            userQueryDisplay.innerHTML = `Recommendation: <a href="${videoUrl}" target="_blank" class="text-blue-400 underline">Watch this Math Short!</a>`;
            
            videoIndex = (videoIndex + 1) % youtubePlaylist.length;
        }

        // --- Event Listeners ---
        activateBtn.addEventListener('click', () => {
            if (!isListening) {
                recognition.start();
            }
        });

    </script>
</body>
</html>
